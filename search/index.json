[{"content":"引入 1982年，中国计算机科学家、2000年图灵奖获得者姚期智教授在论文《Protocols for secure computations》中提出了著名的姚氏百万富翁问题，开创了密码学研究的新领域：安全多方计算(Secure Multi-party Computation)。\n问题描述 有两个百万富翁，Alice 和 Bob。他们想知道谁更富有，但又不愿意向对方透露自己财富的具体数额。换句话说，他们希望在不泄露各自真实财富值的前提下，比较出谁的钱更多。如何在不借助第三方的情况下，让他们知道他们之间谁更有钱？\n思路 我们假设Alice拥有的财富值为 $a$；Bob拥有的财富值为 $b$。假设财富值在 [1, 10] 范围内，这里为简化设为10 。 假设有10个宝箱，编号为1到10，Alice可以打开这10个箱子，而Bob不能。\n第一步：Alice找到编号为 $i$ 的箱子，并将编号为1到 $i-1$ 的箱子里都放个纸条“no”，编号为 $i$ 到10的箱子里放个纸条“yes”，然后锁上箱子。 第二步：Bob根据自己的资产选择编号为的箱子，并把这个箱子的编号撕掉并返回给Alice。（撕掉编号是为了让Alice也不知道Bob到底选了哪个箱子） 第三步：Alice把Bob发的箱子打开，看一下里面的纸条，如果是\u0026quot;no\u0026quot;就说明 $j\u0026lt;i$ ，\u0026ldquo;yes\u0026quot;就说明 $i≤j$。由此可以在互不知道对方财产的前提下，比较二人的财富。 ","date":"2025-09-15T00:00:00Z","image":"http://localhost:1313/p/mpc/ECFBFD5A01583768E301180AF31172B5_hu_df3225e119df3cb1.png","permalink":"http://localhost:1313/p/mpc/","title":"MPC学习笔记"},{"content":"引言 在之前的一篇文章里，我们详细了解了精妙的FFT算法。但它有一个与生俱来的缺点：在复数域上。单位复根的实部和虚部分别是一个正弦及余弦函数，有大量浮点数计算，计算量很大且浮点数运算也会产生较大的误差。\n所以我们可不可以把操作对象变成整数呢？快速数论变换（NTT）应运而生。\n变换 NTT使用的分治办法，与FTT使用的分治办法完全一致。这意味着，只需在FTT的基础上进行简单修改，即可得到NTT。\n原根 对于一个素数 $p$，它的原根 $g$ 是一个整数，使得 $g^1, g^2, \\ldots, g^{p-1} \\mod p$ 这个序列，能够生成整个乘法群 $Z_p^*$（即 ${1, 2, \\ldots, p-1}$ 中的所有元素）。\n换句话说，$g$ 的幂模 $p$ 的结果两两不同，且覆盖了 $1$ 到 $p-1$ 的所有整数。\n例如，素数 $p = 7$。\n检查 $g = 3$：$3^1 \\equiv 3$, $3^2 \\equiv 2$, $3^3 \\equiv 6$, $3^4 \\equiv 4$, $3^5 \\equiv 5$, $3^6 \\equiv 1 \\mod 7$。 序列是 ${3, 2, 6, 4, 5, 1}$，覆盖了 $1-6$ 的所有数。所以 $3$ 是 $7$ 的一个原根。 仿照单位复数根的形式，也将原根的取值看成一个圆，不过这个圆上只有有限个点，每个点表达的是模数的剩余系中的值。\n我们令 $\\omega_n \\equiv g^{(p-1)/n} \\mod p$​。这样定义的 $\\omega_n$ 满足 $n$ 次单位根的性质：\n$\\omega_n^n \\equiv (g^{(p-1)/n})^n \\equiv g^{p-1} \\equiv 1 \\mod p$ （费马小定理） $\\omega_n^{n/2} \\equiv g^{(p-1)/2} \\equiv -1 \\mod p$ （因为 $g^{(p-1)/2}$ 是 $1$ 的平方根，只能是 $\\pm 1$，而根据原根定义，它不能是 $1$，所以是 $-1$） 序列 $\\omega_n^0, \\omega_n^1, \\ldots, \\omega_n^{n-1}$ 是互不相同的。 基于这三点，FFT中的消去引理和折半引理同样成立：\n消去引理：$\\omega_{dn}^{dk} = g^{\\frac{p-1}{dn} \\cdot dk} = g^{\\frac{p-1}{n} \\cdot k} = \\omega_n^k$ 折半引理：$\\omega_n^{k + n/2} = \\omega_n^k \\cdot \\omega_n^{n/2} = \\omega_n^k \\cdot (-1) = -\\omega_n^k$ 完美！现在我们有了一个在整数模 $p$ 域中完美替代复数单位根的元素 $\\omega_n$。\n有了 $\\omega_n$，NTT的实现就和FFT几乎一模一样了。过程依然是：求值（NTT）→ 点乘 → 插值（逆NTT）。\n假设我们有一个多项式 $A(x)$，系数在模 $p$ 下，次数小于 $n$（$n$ 是 $2$ 的幂，且 $n \\mid p-1$）。\n正变换（NTT） 递归分治的过程与FFT完全一致：\n将多项式按奇偶索引分成两个子多项式：$A^{[0]}(x)$ 和 $A^{[1]}(x)$。\n递归计算 $\\operatorname{NTT}(A^{[0]})$ 和 $\\operatorname{NTT}(A^{[1]})$。\n合并结果：\n对于 $k = 0$ 到 $n/2 - 1$：\n$\\operatorname{NTT}(A)[k] = (\\operatorname{NTT}(A^{[0]})[k] + \\omega_n^k \\cdot \\operatorname{NTT}(A^{[1]})[k]) \\mod p$\n$\\operatorname{NTT}(A)[k + n/2] = (\\operatorname{NTT}(A^{[0]})[k] - \\omega_n^k \\cdot \\operatorname{NTT}(A^{[1]})[k]) \\mod p$\n注意：这里的加法、乘法、取模都是在模 $p$ 的整数域中进行的，没有浮点数，没有精度误差！\n逆变换（INTT） 逆NTT（INTT）与NTT的差别仅在于：\n使用 $\\omega_n^{-1} \\mod p$ （即 $\\omega_n$ 的模逆元）代替 $\\omega_n$。 最后结果需要乘以 $n^{-1} \\mod p$ （即 $n$ 的模逆元）。 INTT的公式如下： $\\operatorname{INTT}(A)[k] = \\left( n^{-1} \\cdot \\sum_{j=0}^{n-1} A[j] \\cdot \\omega_n^{-kj} \\right) \\mod p$\n在实际代码中，我们通常使用迭代（非递归） 的蝴蝶操作来实现NTT/INTT，以获得更高的效率。\n模数 $p$ NTT有一个关键限制：变换长度 $n$ 必须是 $p-1$ 的因子。因为我们需要 $\\omega_n = g^{(p-1)/n}$ 是一个整数，这就要求 $n$ 必须能整除 $p-1$。\n常见的做法是选择一些形式特殊的素数，使得 $p-1$ 包含一个非常大的 $2$ 的幂因子。\n常见NTT模数：\n$p = 469762049 = 7 \\cdot 2^{26} + 1$，$g = 3$\n$p = 998244353 = 7\\cdot17 \\cdot 2^{23} + 1$，$g = 3$\n$p = 1004535809 = 479 \\cdot 2^{21} + 1$，$g = 3$\n如果问题中的数值非常大，可能需要使用任意模数NTT（通过CRT合并多个不同模数NTT的结果）。\n小结 假设我们计算 $A(x) \\times B(x) \\mod p$，系数在 $[0, p-1]$ 内。\n补零：确定长度 $N \\geq \\operatorname{len}(A) + \\operatorname{len}(B) - 1$，且 $N$ 是 $2$ 的幂，并且 $N \\mid (p-1)$。 求值（NTT）：计算 $\\vec{A\u0026rsquo;} = \\operatorname{NTT}(\\vec{A})$，$\\vec{B\u0026rsquo;} = \\operatorname{NTT}(\\vec{B})$。 点乘：计算 $\\vec{C\u0026rsquo;}[k] = \\vec{A\u0026rsquo;}[k] \\cdot \\vec{B\u0026rsquo;}[k] \\mod p$，$k=0,1,\\ldots,N-1$。 插值（INTT）：计算 $\\vec{C} = \\operatorname{INTT}(\\vec{C\u0026rsquo;})$。结果 $\\vec{C}$ 就是 $A(x) \\times B(x) \\mod p$ 的系数向量。 数论变换（NTT）完美地将FFT的思想移植到了整数模域中。它通过用原根替代单位根，用模运算替代复数运算，在保留了 $O(n \\log n)$ 高效计算能力的同时，提供了绝对精确的结果和更快的速度，使其成为算法竞赛和工程应用中处理大规模整数、多项式卷积问题的首选利器。\n","date":"2025-09-11T00:00:00Z","image":"http://localhost:1313/p/ntt/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"http://localhost:1313/p/ntt/","title":"NTT学习笔记"},{"content":"引入 假设我们有两个多项式：\n\\( A(x) = a_0 + a_1x + a_2x^2 + ... + a_{n-1}x^{n-1} \\)\n\\( B(x) = b_0 + b_1x + b_2x^2 + ... + b_{m-1}x^{m-1} \\)\n我们希望计算它们的乘积：\n\\( C(x) = A(x) \\times B(x) = c_0 + c_1x + c_2x^2 + ... + c_{(n+m-2)}x^{(n+m-2)} \\)\n其中，每个系数 \\( c_k = \\sum_{i=0}^{k} a_i b_{k-i} \\)。\n如果直接计算（卷积），我们需要计算大约 \\( n \\times m \\) 次乘法和加法。如果 \\( n \\) 和 \\( m \\) 都很大，这个 \\( O(n^2) \\) 的复杂度会非常慢。\n而快速傅里叶变换（FFT）提供了一种将复杂度降至 \\( O(n \\log n) \\) 的方法。\n变换 多项式的标准表示法是系数表示法（Coefficient Representation），即我们上面用的 \\( (a_0, a_1, ..., a_{n-1}) \\)。还有一种等价的表示法，叫做点值表示法（Point-Value Representation）。\n众所周知，两点唯一确定一条直线。那么三个点，四个点，甚至更多点呢？已有证明，一个 \\( n-1 \\) 次多项式可以由其在 \\( n \\) 个不同点 \\( (x_0, x_1, ..., x_{n-1}) \\) 上的取值 \\( (A(x_0), A(x_1), ..., A(x_{n-1})) \\) 唯一确定，咱知道就好。\n点值表示法下的多项式乘法变得极其简单： 假设我们有多项式 \\( A(x) \\) 和 \\( B(x) \\)。\n为 \\( A(x) \\) 取 \\( N \\) 个点：\\( (x_k, A(x_k)) \\)，\\( k=0,1,...,N-1 \\) 为 \\( B(x) \\) 取同样的 \\( N \\) 个点：\\( (x_k, B(x_k)) \\)，\\( k=0,1,...,N-1 \\) 注意，这里 \\( N \\) 必须至少是 \\(deg(A) + deg(B) - 1 \\)，否则乘积多项式 \\( C(x) \\) 无法被唯一确定。 那么乘积 \\( C(x) = A(x) \\times B(x) \\) 在这 \\( N \\) 个点上的值就是： \\( (x_k, C(x_k)) = (x_k, A(x_k) \\times B(x_k)) \\)，\\( k=0,1,...,N-1 \\) 此时点值相乘只需要 \\( O(N) \\) 的时间！这可比 \\( O(N^2) \\) 好多了。\n于是，整个多项式乘法的策略就变成了：系数表示 → 点值表示 → 点值相乘 → 系数表示\n求值（Evaluation）：将 \\( A(x) \\) 和 \\( B(x) \\) 从系数形式转换为点值形式。 点乘（Pointwise Multiplication）：计算 \\( C(x_k) = A(x_k) \\times B(x_k) \\)。 插值（Interpolation）：将 \\( C(x) \\) 从点值形式转换回系数形式。 现在的核心问题是：如何快速地在系数表示和点值表示之间进行转换？ 如果随便选 \\( N \\) 个点，第一步（求值）和第三步（插值）的复杂度仍然是 \\( O(N^2) \\)（因为计算每个 \\( A(x_k) \\) 需要 \\( O(N) \\) 时间）。\nFFT 的精妙就在于它精心选择了一组特殊的点，并利用分治策略，将求值和插值的过程都优化到了 \\( O(N \\log N) \\)。\nDFT 与单位根 FFT 选择的这组特殊的点，是单位根（Roots of Unity）。\n离散傅里叶变换（DFT） 就是将一个多项式 \\( A(x) \\) 在 \\( N \\) 个 \\( N \\)次单位根 \\( \\omega_N^0, \\omega_N^1, ..., \\omega_N^{N-1} \\) 上进行求值，得到的结果 \\( (A(\\omega_N^0), A(\\omega_N^1), ..., A(\\omega_N^{N-1})) \\) 就是其DFT系数。\n\\( N \\)次单位根是方程 \\( z^N = 1 \\) 的 \\( N \\) 个复数解。它们可以被表示为： \\( \\omega_N^k = e^{2\\pi i k / N} = \\cos(\\frac{2\\pi k}{N}) + i \\sin(\\frac{2\\pi k}{N}) \\)， 其中 \\( k = 0, 1, ..., N-1 \\)，\\( i \\) 是虚数单位。\n单位根有几个极其重要的性质，是FFT分治的基础：\n消去引理: \\( \\omega_{2N}^{2k} = \\omega_N^k \\) 折半引理: 如果 \\( N \\) 是偶数，那么 \\( \\omega_N^{k + N/2} = -\\omega_N^k \\) 求和引理：稍后在逆变换中会用到。 分治的魔法 FFT 是快速计算 DFT 的算法。我们假设 \\( N \\) 是 2 的幂（如果不是，可以补零到最近的 2 的幂）。\n我们将多项式 \\( A(x) \\) 按奇偶项分成两个新的、规模减半的多项式：\n\\( A^{[0]}(x) = a_0 + a_2x + a_4x^2 + ... + a_{N-2}x^{N/2 - 1} \\) （偶数索引项）\n\\( A^{[1]}(x) = a_1 + a_3x + a_5x^2 + ... + a_{N-1}x^{N/2 - 1} \\) （奇数索引项）\n很容易发现，原多项式可以表示为： \\( A(x) = A^{[0]}(x^2) + x A^{[1]}(x^2) \\)\n现在，我们的问题从“求 \\( A(x) \\) 在 \\( N \\) 个点 \\( (\\omega_N^0, \\omega_N^1, ..., \\omega_N^{N-1}) \\) 上的值”，变成了“求 \\( A^{[0]}(x) \\) 和 \\( A^{[1]}(x) \\) 在 \\( N/2 \\) 个点 \\( ((\\omega_N^0)^2, (\\omega_N^1)^2, ..., (\\omega_N^{N-1})^2) \\) 上的值”。\n根据消去引理：\\( (\\omega_N^k)^2 = \\omega_{N/2}^k \\) 并且，\\( (\\omega_N^{k + N/2})^2 = (\\omega_N^k \\omega_N^{N/2})^2 = (\\omega_N^k \\cdot -1)^2 = (\\omega_N^k)^2 = \\omega_{N/2}^k \\)\n这意味着，我们需要求值的 \\( N \\) 个平方点，实际上只有 \\( N/2 \\) 个不同的值：\\( \\omega_{N/2}^0, \\omega_{N/2}^1, ..., \\omega_{N/2}^{N/2 - 1} \\)！\n于是，我们可以进行分治递归：\n设 \\( y_k^{[0]} = A^{[0]}(\\omega_{N/2}^k) \\) 设 \\( y_k^{[1]} = A^{[1]}(\\omega_{N/2}^k) \\) 这些是规模为 \\( N/2 \\) 的DFT问题。\n那么，原问题 \\( A(\\omega_N^k) \\) 的解可以通过合并子问题的解得到：\n对于 \\( k = 0, 1, ..., N/2 - 1 \\):\n\\( A(\\omega_N^k) = A^{[0]}(\\omega_{N/2}^k) + \\omega_N^k \\cdot A^{[1]}(\\omega_{N/2}^k) = y_k^{[0]} + \\omega_N^k y_k^{[1]} \\)\n对于 \\( k = N/2, ..., N-1 \\)（令 \\( k’ = k - N/2 \\)）:\n\\( \\omega_N^{k} = \\omega_N^{k’ + N/2} = -\\omega_N^{k’} \\) \\( A(\\omega_N^{k}) = A(\\omega_N^{k’ + N/2}) = A^{[0]}(\\omega_{N/2}^{k’}) + \\omega_N^{k’ + N/2} \\cdot A^{[1]}(\\omega_{N/2}^{k’}) = y_{k’}^{[0]} - \\omega_N^{k’} y_{k’}^{[1]} \\)\n这个过程就是FFT的核心！\n复杂度分析：\n每层递归：我们将一个规模为 \\( N \\) 的问题分解为 2 个规模为 \\( N/2 \\) 的问题，并进行 \\( O(N) \\) 的合并操作（乘以 \\( \\omega_N^k \\) 并相加）。 递归树的高度是 \\( \\log_2 N \\)。 总复杂度：\\( T(N) = 2T(N/2) + O(N) = O(N \\log N) \\)。 IDFT 现在我们有了 \\( C(x) \\) 的点值表示 \\( ((\\omega_N^0, C(\\omega_N^0)), (\\omega_N^1, C(\\omega_N^1)), ..., (\\omega_N^{N-1}, C(\\omega_N^{N-1}))) \\)，如何变回系数 \\( (c_0, c_1, ..., c_{N-1}) \\)？这个过程称为逆离散傅里叶变换（IDFT）。\n神奇的是，IDFT的过程和DFT几乎一模一样。 DFT的矩阵形式是：\n$$ \\begin{bmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_{N-1} \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 1 \u0026 1 \u0026 \\cdots \u0026 1 \\\\ 1 \u0026 \\omega_N \u0026 \\omega_N^2 \u0026 \\cdots \u0026 \\omega_N^{N-1} \\\\ 1 \u0026 \\omega_N^2 \u0026 \\omega_N^4 \u0026 \\cdots \u0026 \\omega_N^{2(N-1)} \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 1 \u0026 \\omega_N^{N-1} \u0026 \\omega_N^{2(N-1)} \u0026 \\cdots \u0026 \\omega_N^{(N-1)(N-1)} \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_{N-1} \\end{bmatrix} $$ 这个范德蒙德矩阵 \\( V \\) 几乎是可逆的。其逆矩阵 \\( V^{-1} \\) 与 \\( V \\) 非常相似，只是把每个元素 \\( \\omega_N^k \\) 替换为 \\( \\omega_N^{-k} \\)，并且整体乘以系数 \\( 1/N \\)。 也就是说，计算IDFT的过程就是：\n将点值向量 \\( \\vec{y} \\) 作为输入。 将单位根 \\( \\omega_N^k \\) 全部替换为其共轭 \\( \\omega_N^{-k} \\)。 执行一遍和FFT完全相同的算法！ 最后将得到的结果除以 \\( N \\)。 所以，IFFT 的复杂度也是 \\( O(N \\log N) \\)。\n小结 假设我们要计算 \\( A(x) \\times B(x) \\)，它们的次数界分别为 \\( n \\) 和 \\( m \\)。\n补零（Zero-padding）：\n确定次数界 \\( N \\geq n + m - 1 \\)，并且 \\( N \\) 是 2 的幂。 将 \\( A(x) \\) 和 \\( B(x) \\) 的系数向量长度都补到 \\( N \\)，后面补零。 求值（FFT）：\n对补零后的 \\( A(x) \\) 的系数向量执行FFT，得到其点值表示 \\( \\vec{A} = (A(\\omega_N^0), A(\\omega_N^1), ..., A(\\omega_N^{N-1})) \\)。 对补零后的 \\( B(x) \\) 的系数向量执行FFT，得到其点值表示 \\( \\vec{B} = (B(\\omega_N^0), B(\\omega_N^1), ..., B(\\omega_N^{N-1})) \\)。 点乘（Pointwise Multiply）：\n计算 \\( \\vec{C} = \\vec{A} \\circ \\vec{B} \\)，即 \\( C(\\omega_N^k) = A(\\omega_N^k) \\times B(\\omega_N^k) \\) for \\( k=0,1,...,N-1 \\)。 插值（IFFT）：\n对点值向量 \\( \\vec{C} \\) 执行逆FFT（即将单位根取共轭，做FFT，再除以N），得到的结果就是乘积多项式 \\( C(x) \\) 的系数向量 \\( (c_0, c_1, ..., c_{N-1}) \\)。 最终复杂度为 \\( O(N \\log N) \\)，远优于直接的 \\( O(N^2) \\)。\n这就是FFT为何在信号处理、图像处理、数值计算等众多领域成为基石算法的原因。它通过巧妙的数学变换和分治策略，极大地加速了卷积（多项式乘法）运算。\n","date":"2025-09-09T00:00:00Z","image":"http://localhost:1313/p/fft/pexels-lum3n-44775-167682_hu_b54557df4f714bdb.jpg","permalink":"http://localhost:1313/p/fft/","title":"FFT学习笔记"}]
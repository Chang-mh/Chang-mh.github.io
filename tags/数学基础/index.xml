<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>数学基础 on ❤️M.H.</title>
        <link>http://localhost:1313/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</link>
        <description>Recent content in 数学基础 on ❤️M.H.</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>M.H.</copyright>
        <lastBuildDate>Thu, 11 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>NTT学习笔记</title>
        <link>http://localhost:1313/p/ntt/</link>
        <pubDate>Thu, 11 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/ntt/</guid>
        <description>&lt;img src="http://localhost:1313/p/ntt/helena-hertz-wWZzXlDpMog-unsplash.jpg" alt="Featured image of post NTT学习笔记" /&gt;&lt;h1 id=&#34;引言&#34;&gt;引言
&lt;/h1&gt;&lt;p&gt;在之前的一篇文章里，我们详细了解了精妙的FFT算法。但它有一个与生俱来的缺点：在复数域上。单位复根的实部和虚部分别是一个正弦及余弦函数，有大量浮点数计算，计算量很大且浮点数运算也会产生较大的误差。&lt;/p&gt;
&lt;p&gt;所以我们可不可以把操作对象变成整数呢？快速数论变换（NTT）应运而生。&lt;/p&gt;
&lt;h1 id=&#34;变换&#34;&gt;变换
&lt;/h1&gt;&lt;p&gt;NTT使用的分治办法，与FTT使用的分治办法完全一致。这意味着，只需在FTT的基础上进行简单修改，即可得到NTT。&lt;/p&gt;
&lt;h2 id=&#34;原根&#34;&gt;原根
&lt;/h2&gt;&lt;p&gt;对于一个素数 $p$，它的原根 $g$ 是一个整数，使得 $g^1, g^2, \ldots, g^{p-1} \mod p$ 这个序列，能够生成整个乘法群 $Z_p^*$（即 ${1, 2, \ldots, p-1}$ 中的所有元素）。&lt;/p&gt;
&lt;p&gt;换句话说，$g$ 的幂模 $p$ 的结果两两不同，且覆盖了 $1$ 到 $p-1$ 的所有整数。&lt;/p&gt;
&lt;p&gt;例如，素数 $p = 7$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查 $g = 3$：$3^1 \equiv 3$, $3^2 \equiv 2$, $3^3 \equiv 6$, $3^4 \equiv 4$, $3^5 \equiv 5$, $3^6 \equiv 1 \mod 7$。&lt;/li&gt;
&lt;li&gt;序列是 ${3, 2, 6, 4, 5, 1}$，覆盖了 $1-6$ 的所有数。所以 $3$ 是 $7$ 的一个原根。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仿照单位复数根的形式，也将原根的取值看成一个圆，不过这个圆上只有有限个点，每个点表达的是模数的剩余系中的值。&lt;/p&gt;
&lt;p&gt;我们令 $\omega_n \equiv g^{(p-1)/n} \mod p$​。这样定义的 $\omega_n$ 满足 $n$ 次单位根的性质：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\omega_n^n \equiv (g^{(p-1)/n})^n \equiv g^{p-1} \equiv 1 \mod p$ （费马小定理）&lt;/li&gt;
&lt;li&gt;$\omega_n^{n/2} \equiv g^{(p-1)/2} \equiv -1 \mod p$ （因为 $g^{(p-1)/2}$ 是 $1$ 的平方根，只能是 $\pm 1$，而根据原根定义，它不能是 $1$，所以是 $-1$）&lt;/li&gt;
&lt;li&gt;序列 $\omega_n^0, \omega_n^1, \ldots, \omega_n^{n-1}$ 是互不相同的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于这三点，FFT中的&lt;strong&gt;消去引理&lt;/strong&gt;和&lt;strong&gt;折半引理&lt;/strong&gt;同样成立：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消去引理&lt;/strong&gt;：$\omega_{dn}^{dk} = g^{\frac{p-1}{dn} \cdot dk} = g^{\frac{p-1}{n} \cdot k} = \omega_n^k$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;折半引理&lt;/strong&gt;：$\omega_n^{k + n/2} = \omega_n^k \cdot \omega_n^{n/2} = \omega_n^k \cdot (-1) = -\omega_n^k$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完美！现在我们有了一个在整数模 $p$ 域中完美替代复数单位根的元素 $\omega_n$。&lt;/p&gt;
&lt;p&gt;有了 $\omega_n$，NTT的实现就和FFT几乎一模一样了。过程依然是：&lt;strong&gt;求值（NTT）→ 点乘 → 插值（逆NTT）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设我们有一个多项式 $A(x)$，系数在模 $p$ 下，次数小于 $n$（$n$ 是 $2$ 的幂，且 $n \mid p-1$）。&lt;/p&gt;
&lt;h2 id=&#34;正变换ntt&#34;&gt;正变换（NTT）
&lt;/h2&gt;&lt;p&gt;递归分治的过程与FFT完全一致：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将多项式按奇偶索引分成两个子多项式：$A^{[0]}(x)$ 和 $A^{[1]}(x)$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;递归计算 $\operatorname{NTT}(A^{[0]})$ 和 $\operatorname{NTT}(A^{[1]})$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;合并结果：&lt;/p&gt;
&lt;p&gt;对于 $k = 0$ 到 $n/2 - 1$：&lt;/p&gt;
&lt;p&gt;$\operatorname{NTT}(A)[k] = (\operatorname{NTT}(A^{[0]})[k] + \omega_n^k \cdot \operatorname{NTT}(A^{[1]})[k]) \mod p$&lt;/p&gt;
&lt;p&gt;$\operatorname{NTT}(A)[k + n/2] = (\operatorname{NTT}(A^{[0]})[k] - \omega_n^k \cdot \operatorname{NTT}(A^{[1]})[k]) \mod p$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里的加法、乘法、取模都是在模 $p$ 的整数域中进行的，没有浮点数，没有精度误差！&lt;/p&gt;
&lt;h2 id=&#34;逆变换intt&#34;&gt;逆变换（INTT）
&lt;/h2&gt;&lt;p&gt;逆NTT（INTT）与NTT的差别仅在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 $\omega_n^{-1} \mod p$ （即 $\omega_n$ 的模逆元）代替 $\omega_n$。&lt;/li&gt;
&lt;li&gt;最后结果需要乘以 $n^{-1} \mod p$ （即 $n$ 的模逆元）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;INTT的公式如下：
$\operatorname{INTT}(A)[k] = \left( n^{-1} \cdot \sum_{j=0}^{n-1} A[j] \cdot \omega_n^{-kj} \right) \mod p$&lt;/p&gt;
&lt;p&gt;在实际代码中，我们通常使用&lt;strong&gt;迭代（非递归）&lt;/strong&gt; 的蝴蝶操作来实现NTT/INTT，以获得更高的效率。&lt;/p&gt;
&lt;h2 id=&#34;模数-p&#34;&gt;模数 $p$
&lt;/h2&gt;&lt;p&gt;NTT有一个关键限制：&lt;strong&gt;变换长度 $n$ 必须是 $p-1$ 的因子&lt;/strong&gt;。因为我们需要 $\omega_n = g^{(p-1)/n}$ 是一个整数，这就要求 $n$ 必须能整除 $p-1$。&lt;/p&gt;
&lt;p&gt;常见的做法是选择一些形式特殊的素数，使得 $p-1$ 包含一个非常大的 $2$ 的幂因子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见NTT模数&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;$p = 469762049 = 7 \cdot 2^{26} + 1$，$g = 3$&lt;/p&gt;
&lt;p&gt;$p = 998244353 = 7\cdot17 \cdot 2^{23} + 1$，$g = 3$&lt;/p&gt;
&lt;p&gt;$p = 1004535809 = 479 \cdot 2^{21} + 1$，$g = 3$&lt;/p&gt;
&lt;p&gt;如果问题中的数值非常大，可能需要使用&lt;strong&gt;任意模数NTT&lt;/strong&gt;（通过CRT合并多个不同模数NTT的结果）。&lt;/p&gt;
&lt;h1 id=&#34;小结&#34;&gt;小结
&lt;/h1&gt;&lt;p&gt;假设我们计算 $A(x) \times B(x) \mod p$，系数在 $[0, p-1]$ 内。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;补零&lt;/strong&gt;：确定长度 $N \geq \operatorname{len}(A) + \operatorname{len}(B) - 1$，且 $N$ 是 $2$ 的幂，并且 $N \mid (p-1)$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;求值（NTT）&lt;/strong&gt;：计算 $\vec{A&amp;rsquo;} = \operatorname{NTT}(\vec{A})$，$\vec{B&amp;rsquo;} = \operatorname{NTT}(\vec{B})$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;点乘&lt;/strong&gt;：计算 $\vec{C&amp;rsquo;}[k] = \vec{A&amp;rsquo;}[k] \cdot \vec{B&amp;rsquo;}[k] \mod p$，$k=0,1,\ldots,N-1$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插值（INTT）&lt;/strong&gt;：计算 $\vec{C} = \operatorname{INTT}(\vec{C&amp;rsquo;})$。结果 $\vec{C}$ 就是 $A(x) \times B(x) \mod p$ 的系数向量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数论变换（NTT）完美地将FFT的思想移植到了整数模域中。它通过用&lt;strong&gt;原根&lt;/strong&gt;替代&lt;strong&gt;单位根&lt;/strong&gt;，用&lt;strong&gt;模运算&lt;/strong&gt;替代复数运算，在保留了 $O(n \log n)$ 高效计算能力的同时，提供了绝对精确的结果和更快的速度，使其成为算法竞赛和工程应用中处理大规模整数、多项式卷积问题的首选利器。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>FFT学习笔记</title>
        <link>http://localhost:1313/p/fft/</link>
        <pubDate>Tue, 09 Sep 2025 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/p/fft/</guid>
        <description>&lt;img src="http://localhost:1313/p/fft/pexels-lum3n-44775-167682.jpg" alt="Featured image of post FFT学习笔记" /&gt;&lt;h1 id=&#34;引入&#34;&gt;引入
&lt;/h1&gt;&lt;p&gt;假设我们有两个多项式：&lt;/p&gt;
&lt;p&gt;\( A(x) = a_0 + a_1x + a_2x^2 + ... + a_{n-1}x^{n-1} \)&lt;/p&gt;
&lt;p&gt;\( B(x) = b_0 + b_1x + b_2x^2 + ... + b_{m-1}x^{m-1} \)&lt;/p&gt;
&lt;p&gt;我们希望计算它们的乘积：&lt;/p&gt;
&lt;p&gt;\( C(x) = A(x) \times B(x) = c_0 + c_1x + c_2x^2 + ... + c_{(n+m-2)}x^{(n+m-2)} \)&lt;/p&gt;
&lt;p&gt;其中，每个系数 \( c_k = \sum_{i=0}^{k} a_i b_{k-i} \)。&lt;/p&gt;
&lt;p&gt;如果&lt;strong&gt;直接计算（卷积）&lt;/strong&gt;，我们需要计算大约 \( n \times m \) 次乘法和加法。如果 \( n \) 和 \( m \) 都很大，这个 \( O(n^2) \) 的复杂度会非常慢。&lt;/p&gt;
&lt;p&gt;而快速傅里叶变换（FFT）提供了一种将复杂度降至 \( O(n \log n) \) 的方法。&lt;/p&gt;
&lt;h1 id=&#34;变换&#34;&gt;变换
&lt;/h1&gt;&lt;p&gt;多项式的标准表示法是&lt;strong&gt;系数表示法&lt;/strong&gt;（Coefficient Representation），即我们上面用的 \( (a_0, a_1, ..., a_{n-1}) \)。还有一种等价的表示法，叫做&lt;strong&gt;点值表示法&lt;/strong&gt;（Point-Value Representation）。&lt;/p&gt;
&lt;p&gt;众所周知，两点唯一确定一条直线。那么三个点，四个点，甚至更多点呢？已有证明，一个 \( n-1 \) 次多项式可以由其在 \( n \) 个不同点 \( (x_0, x_1, ..., x_{n-1}) \) 上的取值 \( (A(x_0), A(x_1), ..., A(x_{n-1})) \) &lt;strong&gt;唯一确定&lt;/strong&gt;，咱知道就好。&lt;/p&gt;
&lt;p&gt;点值表示法下的多项式乘法变得极其简单：
假设我们有多项式 \( A(x) \) 和 \( B(x) \)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为 \( A(x) \) 取 \( N \) 个点：\( (x_k, A(x_k)) \)，\( k=0,1,...,N-1 \)&lt;/li&gt;
&lt;li&gt;为 \( B(x) \) 取&lt;strong&gt;同样&lt;/strong&gt;的 \( N \) 个点：\( (x_k, B(x_k)) \)，\( k=0,1,...,N-1 \)
&lt;em&gt;注意，这里 \( N \) 必须至少是 \(deg(A) + deg(B) - 1 \)，否则乘积多项式 \( C(x) \) 无法被唯一确定。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;那么乘积 \( C(x) = A(x) \times B(x) \) 在这 \( N \) 个点上的值就是：
\( (x_k, C(x_k)) = (x_k, A(x_k) \times B(x_k)) \)，\( k=0,1,...,N-1 \)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时点值相乘只需要 \( O(N) \) 的时间！这可比 \( O(N^2) \) 好多了。&lt;/p&gt;
&lt;p&gt;于是，整个多项式乘法的策略就变成了：&lt;strong&gt;系数表示 → 点值表示 → 点值相乘 → 系数表示&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;求值（Evaluation）：将 \( A(x) \) 和 \( B(x) \) 从系数形式转换为点值形式。&lt;/li&gt;
&lt;li&gt;点乘（Pointwise Multiplication）：计算 \( C(x_k) = A(x_k) \times B(x_k) \)。&lt;/li&gt;
&lt;li&gt;插值（Interpolation）：将 \( C(x) \) 从点值形式转换回系数形式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在的核心问题是：&lt;strong&gt;如何快速地在系数表示和点值表示之间进行转换？&lt;/strong&gt;
如果随便选 \( N \) 个点，第一步（求值）和第三步（插值）的复杂度仍然是 \( O(N^2) \)（因为计算每个 \( A(x_k) \) 需要 \( O(N) \) 时间）。&lt;/p&gt;
&lt;p&gt;FFT 的精妙就在于它&lt;strong&gt;精心选择了一组特殊的点&lt;/strong&gt;，并利用&lt;strong&gt;分治策略&lt;/strong&gt;，将求值和插值的过程都优化到了 \( O(N \log N) \)。&lt;/p&gt;
&lt;h2 id=&#34;dft-与单位根&#34;&gt;DFT 与单位根
&lt;/h2&gt;&lt;p&gt;FFT 选择的这组特殊的点，是&lt;strong&gt;单位根（Roots of Unity）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离散傅里叶变换（DFT）&lt;/strong&gt; 就是将一个多项式 \( A(x) \) 在 \( N \) 个 &lt;strong&gt;\( N \)次单位根&lt;/strong&gt; \( \omega_N^0, \omega_N^1, ..., \omega_N^{N-1} \) 上进行求值，得到的结果 \( (A(\omega_N^0), A(\omega_N^1), ..., A(\omega_N^{N-1})) \) 就是其DFT系数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;\( N \)次单位根&lt;/strong&gt;是方程 \( z^N = 1 \) 的 \( N \) 个复数解。它们可以被表示为：
\( \omega_N^k = e^{2\pi i k / N} = \cos(\frac{2\pi k}{N}) + i \sin(\frac{2\pi k}{N}) \)， 其中 \( k = 0, 1, ..., N-1 \)，\( i \) 是虚数单位。&lt;/p&gt;
&lt;p&gt;单位根有几个&lt;strong&gt;极其重要的性质&lt;/strong&gt;，是FFT分治的基础：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;消去引理&lt;/strong&gt;: \( \omega_{2N}^{2k} = \omega_N^k \)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;折半引理&lt;/strong&gt;: 如果 \( N \) 是偶数，那么 \( \omega_N^{k + N/2} = -\omega_N^k \)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;求和引理&lt;/strong&gt;：稍后在逆变换中会用到。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;分治的魔法&#34;&gt;分治的魔法
&lt;/h2&gt;&lt;p&gt;FFT 是快速计算 DFT 的算法。我们假设 \( N \) 是 2 的幂（如果不是，可以补零到最近的 2 的幂）。&lt;/p&gt;
&lt;p&gt;我们将多项式 \( A(x) \) 按奇偶项分成两个新的、规模减半的多项式：&lt;/p&gt;
&lt;p&gt;\( A^{[0]}(x) = a_0 + a_2x + a_4x^2 + ... + a_{N-2}x^{N/2 - 1} \) （偶数索引项）&lt;/p&gt;
&lt;p&gt;\( A^{[1]}(x) = a_1 + a_3x + a_5x^2 + ... + a_{N-1}x^{N/2 - 1} \) （奇数索引项）&lt;/p&gt;
&lt;p&gt;很容易发现，原多项式可以表示为：
\( A(x) = A^{[0]}(x^2) + x A^{[1]}(x^2) \)&lt;/p&gt;
&lt;p&gt;现在，我们的问题从“求 \( A(x) \) 在 \( N \) 个点 \( (\omega_N^0, \omega_N^1, ..., \omega_N^{N-1}) \) 上的值”，变成了“求 \( A^{[0]}(x) \) 和 \( A^{[1]}(x) \) 在 \( N/2 \) 个点 \( ((\omega_N^0)^2, (\omega_N^1)^2, ..., (\omega_N^{N-1})^2) \) 上的值”。&lt;/p&gt;
&lt;p&gt;根据&lt;strong&gt;消去引理&lt;/strong&gt;：\( (\omega_N^k)^2 = \omega_{N/2}^k \)
并且，\( (\omega_N^{k + N/2})^2 = (\omega_N^k \omega_N^{N/2})^2 = (\omega_N^k \cdot -1)^2 = (\omega_N^k)^2 = \omega_{N/2}^k \)&lt;/p&gt;
&lt;p&gt;这意味着，我们需要求值的 \( N \) 个平方点，实际上只有 \( N/2 \) 个&lt;strong&gt;不同的值&lt;/strong&gt;：\( \omega_{N/2}^0, \omega_{N/2}^1, ..., \omega_{N/2}^{N/2 - 1} \)！&lt;/p&gt;
&lt;p&gt;于是，我们可以进行&lt;strong&gt;分治递归&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;设 \( y_k^{[0]} = A^{[0]}(\omega_{N/2}^k) \)
设 \( y_k^{[1]} = A^{[1]}(\omega_{N/2}^k) \)
这些是规模为 \( N/2 \) 的DFT问题。&lt;/p&gt;
&lt;p&gt;那么，原问题 \( A(\omega_N^k) \) 的解可以通过合并子问题的解得到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于 \( k = 0, 1, ..., N/2 - 1 \):&lt;/p&gt;
&lt;p&gt;\( A(\omega_N^k) = A^{[0]}(\omega_{N/2}^k) + \omega_N^k \cdot A^{[1]}(\omega_{N/2}^k) = y_k^{[0]} + \omega_N^k y_k^{[1]} \)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 \( k = N/2, ..., N-1 \)（令 \( k’ = k - N/2 \)）:&lt;/p&gt;
&lt;p&gt;\( \omega_N^{k} = \omega_N^{k’ + N/2} = -\omega_N^{k’} \)
\( A(\omega_N^{k}) = A(\omega_N^{k’ + N/2}) = A^{[0]}(\omega_{N/2}^{k’}) + \omega_N^{k’ + N/2} \cdot A^{[1]}(\omega_{N/2}^{k’}) = y_{k’}^{[0]} - \omega_N^{k’} y_{k’}^{[1]} \)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;这个过程就是FFT的核心！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每层递归：我们将一个规模为 \( N \) 的问题分解为 2 个规模为 \( N/2 \) 的问题，并进行 \( O(N) \) 的合并操作（乘以 \( \omega_N^k \) 并相加）。&lt;/li&gt;
&lt;li&gt;递归树的高度是 \( \log_2 N \)。&lt;/li&gt;
&lt;li&gt;总复杂度：\( T(N) = 2T(N/2) + O(N) = O(N \log N) \)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;idft&#34;&gt;IDFT
&lt;/h2&gt;&lt;p&gt;现在我们有了 \( C(x) \) 的点值表示 \( ((\omega_N^0, C(\omega_N^0)), (\omega_N^1, C(\omega_N^1)), ..., (\omega_N^{N-1}, C(\omega_N^{N-1}))) \)，如何变回系数 \( (c_0, c_1, ..., c_{N-1}) \)？这个过程称为&lt;strong&gt;逆离散傅里叶变换（IDFT）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;神奇的是，&lt;strong&gt;IDFT的过程和DFT几乎一模一样&lt;/strong&gt;。
DFT的矩阵形式是：&lt;/p&gt;
&lt;div&gt;
$$
\begin{bmatrix}
y_0 \\
y_1 \\
y_2 \\
\vdots \\
y_{N-1}
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \\
1 &amp; \omega_N &amp; \omega_N^2 &amp; \cdots &amp; \omega_N^{N-1} \\
1 &amp; \omega_N^2 &amp; \omega_N^4 &amp; \cdots &amp; \omega_N^{2(N-1)} \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; \omega_N^{N-1} &amp; \omega_N^{2(N-1)} &amp; \cdots &amp; \omega_N^{(N-1)(N-1)}
\end{bmatrix}
\begin{bmatrix}
a_0 \\
a_1 \\
a_2 \\
\vdots \\
a_{N-1}
\end{bmatrix}
$$
&lt;/div&gt;
这个范德蒙德矩阵 \( V \) 几乎是可逆的。其逆矩阵 \( V^{-1} \) 与 \( V \) 非常相似，只是把每个元素 \( \omega_N^k \) 替换为 \( \omega_N^{-k} \)，并且整体乘以系数 \( 1/N \)。
&lt;p&gt;也就是说，&lt;strong&gt;计算IDFT的过程就是&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将点值向量 \( \vec{y} \) 作为输入。&lt;/li&gt;
&lt;li&gt;将单位根 \( \omega_N^k \) 全部替换为其&lt;strong&gt;共轭&lt;/strong&gt; \( \omega_N^{-k} \)。&lt;/li&gt;
&lt;li&gt;执行一遍和FFT完全相同的算法！&lt;/li&gt;
&lt;li&gt;最后将得到的结果&lt;strong&gt;除以 \( N \)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，IFFT 的复杂度也是 \( O(N \log N) \)。&lt;/p&gt;
&lt;h1 id=&#34;小结&#34;&gt;小结
&lt;/h1&gt;&lt;p&gt;假设我们要计算 \( A(x) \times B(x) \)，它们的次数界分别为 \( n \) 和 \( m \)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;补零（Zero-padding）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定次数界 \( N \geq n + m - 1 \)，并且 \( N \) 是 2 的幂。&lt;/li&gt;
&lt;li&gt;将 \( A(x) \) 和 \( B(x) \) 的系数向量长度都补到 \( N \)，后面补零。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;求值（FFT）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对补零后的 \( A(x) \) 的系数向量执行FFT，得到其点值表示 \( \vec{A} = (A(\omega_N^0), A(\omega_N^1), ..., A(\omega_N^{N-1})) \)。&lt;/li&gt;
&lt;li&gt;对补零后的 \( B(x) \) 的系数向量执行FFT，得到其点值表示 \( \vec{B} = (B(\omega_N^0), B(\omega_N^1), ..., B(\omega_N^{N-1})) \)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;点乘（Pointwise Multiply）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算 \( \vec{C} = \vec{A} \circ \vec{B} \)，即 \( C(\omega_N^k) = A(\omega_N^k) \times B(\omega_N^k) \) for \( k=0,1,...,N-1 \)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;插值（IFFT）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对点值向量 \( \vec{C} \) 执行&lt;strong&gt;逆FFT&lt;/strong&gt;（即将单位根取共轭，做FFT，再除以N），得到的结果就是乘积多项式 \( C(x) \) 的系数向量 \( (c_0, c_1, ..., c_{N-1}) \)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终复杂度为 \( O(N \log N) \)，远优于直接的 \( O(N^2) \)。&lt;/p&gt;
&lt;p&gt;这就是FFT为何在信号处理、图像处理、数值计算等众多领域成为基石算法的原因。它通过巧妙的数学变换和分治策略，极大地加速了卷积（多项式乘法）运算。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
